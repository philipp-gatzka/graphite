/*
 * Copyright 2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.graphite.codegen;

import com.palantir.javapoet.JavaFile;
import io.github.graphite.codegen.generator.EnumGenerator;
import io.github.graphite.codegen.generator.InputTypeGenerator;
import io.github.graphite.codegen.generator.InterfaceGenerator;
import io.github.graphite.codegen.generator.MutationGenerator;
import io.github.graphite.codegen.generator.ProjectionGenerator;
import io.github.graphite.codegen.generator.QueryGenerator;
import io.github.graphite.codegen.generator.TypeGenerator;
import io.github.graphite.codegen.generator.UnionGenerator;
import io.github.graphite.codegen.schema.SchemaModel;
import io.github.graphite.codegen.schema.SchemaParser;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HexFormat;
import java.util.List;
import java.util.Objects;
import org.jetbrains.annotations.NotNull;

/**
 * Main orchestrator for GraphQL code generation.
 *
 * <p>This class coordinates the entire code generation process:
 *
 * <ul>
 *   <li>Validates the configuration
 *   <li>Checks if generation can be skipped (incremental builds)
 *   <li>Parses the GraphQL schema from schema.json
 *   <li>Invokes appropriate generators for each type category
 *   <li>Writes generated Java source files
 * </ul>
 *
 * <p>Example usage:
 *
 * <pre>{@code
 * CodegenConfiguration config = CodegenConfiguration.builder()
 *     .schemaFile(Path.of("src/main/resources/schema.json"))
 *     .outputDirectory(Path.of("build/generated/sources/graphite"))
 *     .packageName("com.example.graphql")
 *     .build();
 *
 * GraphiteCodegen codegen = new GraphiteCodegen(config);
 * CodegenResult result = codegen.generate();
 *
 * System.out.println("Generated " + result.filesGenerated() + " files");
 * }</pre>
 *
 * @see CodegenConfiguration
 * @see CodegenResult
 */
public final class GraphiteCodegen {

  private static final String HASH_FILE_NAME = ".graphite-schema-hash";
  private static final String GENERATED_HEADER =
      "// Generated by Graphite Codegen - DO NOT EDIT\n\n";

  private final CodegenConfiguration configuration;
  private final SchemaParser schemaParser;

  /**
   * Creates a new code generator with the specified configuration.
   *
   * @param configuration the code generation configuration
   * @throws NullPointerException if configuration is null
   */
  public GraphiteCodegen(@NotNull CodegenConfiguration configuration) {
    this.configuration = Objects.requireNonNull(configuration, "configuration must not be null");
    this.schemaParser = new SchemaParser();
  }

  /**
   * Executes the code generation process.
   *
   * <p>This method will:
   *
   * <ol>
   *   <li>Validate that the schema file exists
   *   <li>Check if generation can be skipped (if skipIfUpToDate is enabled)
   *   <li>Parse the schema
   *   <li>Generate Java source files for all types
   *   <li>Update the schema hash for incremental builds
   * </ol>
   *
   * @return the result of code generation
   * @throws CodegenException if code generation fails
   */
  @NotNull
  public CodegenResult generate() {
    validateConfiguration();

    // Check if we can skip generation
    if (configuration.skipIfUpToDate() && isUpToDate()) {
      return CodegenResult.skipped();
    }

    try {
      // Ensure output directory exists
      Files.createDirectories(configuration.outputDirectory());

      // Parse the schema
      SchemaModel schema = schemaParser.parse(configuration.schemaFile());

      // Generate all files
      List<JavaFile> files = generateAllFiles(schema);

      // Write files to output directory
      int filesGenerated = writeFiles(files);

      // Update the hash file for incremental builds
      updateSchemaHash();

      return CodegenResult.success(filesGenerated);

    } catch (IOException e) {
      throw new CodegenException("Failed to generate code", e);
    }
  }

  /**
   * Validates that the configuration is valid for code generation.
   *
   * @throws CodegenException if the configuration is invalid
   */
  private void validateConfiguration() {
    Path schemaFile = configuration.schemaFile();

    if (!Files.exists(schemaFile)) {
      throw new CodegenException("Schema file does not exist: " + schemaFile);
    }

    if (!Files.isRegularFile(schemaFile)) {
      throw new CodegenException("Schema path is not a file: " + schemaFile);
    }

    if (!Files.isReadable(schemaFile)) {
      throw new CodegenException("Schema file is not readable: " + schemaFile);
    }
  }

  /**
   * Checks if the schema has changed since the last generation.
   *
   * @return true if the generated code is up-to-date
   */
  private boolean isUpToDate() {
    Path hashFile = configuration.outputDirectory().resolve(HASH_FILE_NAME);

    if (!Files.exists(hashFile)) {
      return false;
    }

    try {
      String storedHash = Files.readString(hashFile).trim();
      String currentHash = computeSchemaHash();
      return storedHash.equals(currentHash);
    } catch (IOException e) {
      // If we can't read the hash, assume we need to regenerate
      return false;
    }
  }

  /**
   * Updates the stored schema hash after successful generation.
   *
   * @throws IOException if the hash file cannot be written
   */
  private void updateSchemaHash() throws IOException {
    Path hashFile = configuration.outputDirectory().resolve(HASH_FILE_NAME);
    String hash = computeSchemaHash();
    Files.writeString(hashFile, hash);
  }

  /**
   * Computes the SHA-256 hash of the schema file.
   *
   * @return the hex-encoded hash
   */
  private String computeSchemaHash() {
    try {
      MessageDigest digest = MessageDigest.getInstance("SHA-256");
      byte[] content = Files.readAllBytes(configuration.schemaFile());
      byte[] hash = digest.digest(content);
      return HexFormat.of().formatHex(hash);
    } catch (NoSuchAlgorithmException e) {
      throw new CodegenException("SHA-256 algorithm not available", e);
    } catch (IOException e) {
      throw new CodegenException("Failed to read schema file for hashing", e);
    }
  }

  /**
   * Generates all Java source files from the parsed schema.
   *
   * <p>This method invokes all generators in the correct order:
   *
   * <ol>
   *   <li>EnumGenerator - generates Java enums
   *   <li>InterfaceGenerator - generates sealed interfaces for GraphQL interfaces
   *   <li>UnionGenerator - generates sealed marker interfaces for unions
   *   <li>TypeGenerator - generates DTOs (must run after interfaces/unions)
   *   <li>InputTypeGenerator - generates input type classes
   *   <li>ProjectionGenerator - generates field selection builders
   *   <li>QueryGenerator - generates query operation classes
   *   <li>MutationGenerator - generates mutation operation classes
   * </ol>
   *
   * @param schema the parsed schema model
   * @return list of generated Java files
   */
  @NotNull
  private List<JavaFile> generateAllFiles(@NotNull SchemaModel schema) {
    List<JavaFile> files = new ArrayList<>();

    // Generate enums first (no dependencies)
    files.addAll(new EnumGenerator(configuration, schema).generate());

    // Generate interfaces (no dependencies)
    files.addAll(new InterfaceGenerator(configuration, schema).generate());

    // Generate unions (no dependencies)
    files.addAll(new UnionGenerator(configuration, schema).generate());

    // Generate DTOs (depends on interfaces and unions for implements clause)
    files.addAll(new TypeGenerator(configuration, schema).generate());

    // Generate input types (no dependencies on other generated types)
    files.addAll(new InputTypeGenerator(configuration, schema).generate());

    // Generate projections (depends on types for field references)
    files.addAll(new ProjectionGenerator(configuration, schema).generate());

    // Generate queries (depends on projections and input types)
    files.addAll(new QueryGenerator(configuration, schema).generate());

    // Generate mutations (depends on projections and input types)
    files.addAll(new MutationGenerator(configuration, schema).generate());

    return files;
  }

  /**
   * Writes generated Java files to the output directory.
   *
   * <p>Each file is written with a generated header comment and proper directory structure based on
   * the package name.
   *
   * @param files the Java files to write
   * @return the number of files written
   * @throws IOException if a file cannot be written
   */
  private int writeFiles(@NotNull List<JavaFile> files) throws IOException {
    int count = 0;
    for (JavaFile file : files) {
      // Build the output path based on package
      Path packagePath =
          configuration.outputDirectory().resolve(file.packageName().replace('.', '/'));
      Files.createDirectories(packagePath);

      Path filePath = packagePath.resolve(file.typeSpec().name() + ".java");

      // Write file with header
      String content = GENERATED_HEADER + file.toString();
      Files.writeString(filePath, content, StandardCharsets.UTF_8);
      count++;
    }
    return count;
  }

  /**
   * Returns the configuration for this code generator.
   *
   * @return the configuration
   */
  @NotNull
  public CodegenConfiguration getConfiguration() {
    return configuration;
  }
}
